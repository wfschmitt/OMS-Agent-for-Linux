#! /bin/bash

#
# Helper functions for omsagent service control
#
# This script can be "sourced" (if sourcing with the "functions" qualifer),
# which is used by the service control scripts. This allows for deeper control
# of the process at a low level.
#
# NOTE:  Sourcing through Bourne Shell and Dash does not allow ANY qualifier,
#   so the above is probably only working in Bash and perhaps Kornshell and zsh.
#
# Otherwise (this is the normal case), invoke this with one of the following
# options:
#
#    start:    Start the OMS service via the service control manager
#    stop:     Stop the OMS service via the service control manager
#    restart:  Restart the OMS service via the service control manager
#    reload:   Reload agent configuration
#

VAR_DIR=/var/opt/microsoft/omsagent
ETC_DIR=/etc/opt/microsoft/omsagent
BIN_DIR=/opt/microsoft/omsagent/bin

REGEX_UUID='[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
WORKSPACE_REGEX="^$REGEX_UUID$"
VALIDATION_SUPPLEMENT_MESSAGE=
VALIDATION_SEVERITY=WARNING

# Space seperated list of non oms workspaces
NON_OMS_WS="scom"

# Begin Lower Level Utilities

validate_file_has_line_pattern() {
	local _fSpec=$1
	local _pattA="$2"
	local _boolOnly=$3
	cat $_fSpec | grep -Eq "^$_pattA$"
	if [ $? -eq 0 ]; then
		return 0
	fi
	if [ -z "$_boolOnly" ]; then
		echo "$VALIDATION_SEVERITY:  $_fSpec missing required pattern '$_pattA'."
        echo $VALIDATION_SUPPLEMENT_MESSAGE
	fi
	exit 1
}

# End Lower Level Utilities

# Begin FailCount Singleton Interface

fcso_any_failures() {
    return $FCSO_FailCount
}

fcso_increment() {
    if [ $# -ne 3 ]; then
        echo "FATAL:  Programmer error; 3 arguments required for fcso_increment!"
        echo "$# arguments seen."
        exit 99
    fi
    local _actStr=$1
    local _wId=$2
    local _sCode=$3

    if [ "$_sCode" -eq 0 ]; then
        return
    else
        FCSO_FailCount=`expr $FCSO_FailCount + 1`
    fi
    echo "ERROR:  $_actStr failed with result '$_sCode' on WS Id $_wId."
}

fcso_new() {
    FCSO_FailCount=0 # Supposed to be NOT local.
}

# End FailCount Singleton Interface

setup_variables() {

    local initial_conf_dir=
    if [ -z "$1" ]; then
        initial_conf_dir="$ETC_DIR/conf/omsadmin.conf"
    else
        initial_conf_dir="$ETC_DIR/$1/conf/omsadmin.conf"
    fi

    validate_omsadmin_conf $initial_conf_dir
    . $initial_conf_dir

    VAR_DIR_WS=$VAR_DIR/$WORKSPACE_ID
    ETC_DIR_WS=$ETC_DIR/$WORKSPACE_ID

    TMP_DIR=$VAR_DIR_WS/tmp
    STATE_DIR=$VAR_DIR_WS/state
    RUN_DIR=$VAR_DIR_WS/run
    LOG_DIR=$VAR_DIR_WS/log
    CERT_DIR=$ETC_DIR_WS/certs
    CONF_DIR=$ETC_DIR_WS/conf

    LOGFILE=$LOG_DIR/omsagent.log
    PIDFILE=$RUN_DIR/omsagent.pid
    CONFFILE=$CONF_DIR/omsagent.conf
    OMSADMIN_CONF=$CONF_DIR/omsadmin.conf

    OMSAGENT_WS=omsagent-$WORKSPACE_ID

    WS_STATUS=0
}

validate_omsadmin_conf() {
    local _fSpec=$1
    local _boolOnly=$2
    VALIDATION_SUPPLEMENT_MESSAGE="Onboarding incorrect or incomplete."
    if [ -f $_fSpec ]; then
        validate_file_has_line_pattern $_fSpec "WORKSPACE_ID=$REGEX_UUID" $_boolOnly
        validate_file_has_line_pattern $_fSpec "AGENT_GUID=$REGEX_UUID" $_boolOnly
        validate_file_has_line_pattern $_fSpec "LOG_FACILITY=.*" $_boolOnly
        validate_file_has_line_pattern $_fSpec "CERTIFICATE_UPDATE_ENDPOINT=.*" $_boolOnly
        validate_file_has_line_pattern $_fSpec "URL_TLD=.*" $_boolOnly
        validate_file_has_line_pattern $_fSpec "DSC_ENDPOINT=.*" $_boolOnly
        validate_file_has_line_pattern $_fSpec "OMS_ENDPOINT=.*" $_boolOnly
        validate_file_has_line_pattern $_fSpec "AZURE_RESOURCE_ID=.*" $_boolOnly
        validate_file_has_line_pattern $_fSpec "OMSCLOUD_ID=.*" $_boolOnly
        validate_file_has_line_pattern $_fSpec "UUID=$REGEX_UUID" $_boolOnly
        return 0
    else
        if [ -z "$_boolOnly" ]; then
            echo "WARNING:  OMS Admin configuration file $OMSADMIN_CONF NOT Found!" >&2
            echo $VALIDATION_SUPPLEMENT_MESSAGE
        fi
        exit 2
    fi
}

verify_privileges()
{
    if [ `id -u` -ne 0 ]; then
        echo "Must have root privileges for this operation" >& 2
        exit 1
    fi
}

this_omsagent_running() {
    if [ -f $PIDFILE ]; then
        if ps -p `cat $PIDFILE` | grep -q omsagent
        then
            WS_STATUS=0
            return $WS_STATUS
        fi
    fi
    WS_STATUS=1
    return $WS_STATUS
}

is_omsagent_running()
{
    # Returns 1 if 'omsagent' is running, 0 otherwise
	#### Keeping return value on this as it originally was.  I deduce
    #### that because this value is returned with the is-running qualifier
	#### to service_control, that there are scripts in other languages
	#### that use the more conventional values for booleans.  Meanwhile,
	#### I recommend deprecation in all but the external interface.  XC
    if this_omsagent_running; then
		return 1
	else
		return 0
	fi
} 

remove_PIDfile_unless_omsagent_running() {

	WS_STATUS=0
	if this_omsagent_running; then
		return 0
	fi
	rm -f $PIDFILE # NOTE:  definition of PIDFILE is dependent on WS.
	if [ $? -ne 0 ]; then
		WS_STATUS=2
		return $WS_STATUS
	fi
	return 1
}

exit_if_agent_not_onboarded()
{
    if [ ! -f $OMSADMIN_CONF ]; then
        echo "FATAL: Agent is not onboarded. omsagent cannot be registered as a service."
		WS_STATUS=9
        exit $WS_STATUS
    fi
}

wait_until_omsagent_stops()
{
    # Required parameter: Number of seconds to wait for agent to stop
    if [ -z "$1" -o "$1" -le 0 ]; then
        echo "Function \"wait_until_omsagent_stops\" called with invalid parameter"
        WS_STATUS=1
        exit $WS_STATUS
    fi

    COUNTER=$(( $1 * 2 )) # Since we sleep 0.5 seconds, compute number of seconds
    while [ $COUNTER -gt 0 ]; do
        if is_omsagent_running; then
            COUNTER=$(( $COUNTER - 1 ))
            sleep 0.5
        else
            remove_PIDfile_unless_omsagent_running
            WS_STATUS=$? # Should only be non-zero of the removal of a PIDFILE failed for some reason.
            return $WS_STATUS
        fi
    done

    # One final try for accurate return status (just return status from the call)
    remove_PIDfile_unless_omsagent_running
    WS_STATUS=$? # Should only be non-zero of the removal of a PIDFILE failed for some reason.
    return $WS_STATUS
}

stop_omsagent_process()
{
    # First try sending a graceful shutdown request.
    # If omsagent doesn't stop, forcefully kill it.
    #
    # TODO: omsagent doesn't currently gracefully shut down, we're investigating this later

    if ! remove_PIDfile_unless_omsagent_running; then
        WS_STATUS=$?
        return $WS_STATUS
    fi

    #  XC on 20170824; Looks like the following two lines can be removed:
    # kill -sigterm `cat $PIDFILE`
    # wait_until_omsagent_stops 10 && return $?

    echo -n "(Forced) "
    kill -sigkill `cat $PIDFILE`
    wait_until_omsagent_stops 5
    WS_STATUS=$?
    return $WS_STATUS
}

    #  XC on 20170824; Laura says this is no longer used:
start_omsagent_process()
{
    if remove_PIDfile_unless_omsagent_running; then
        $BIN_DIR/omsagent -d $PIDFILE --no-supervisor -o $LOGFILE -c $CONFFILE
    fi
    WS_STATUS=$?
    return $WS_STATUS
}

#
# Normal usage functions (used by everything except service control scripts)
#

start_omsagent()
{
    exit_if_agent_not_onboarded
    enable_omsagent_service
    if remove_PIDfile_unless_omsagent_running; then
        WS_STATUS=$?
        return $WS_STATUS
    fi

    # If systemd lives here, then we have a systemd unit file
    if pidof systemd 1> /dev/null 2> /dev/null; then
        /bin/systemctl start $OMSAGENT_WS
    else
        if [ -x /usr/sbin/invoke-rc.d ]; then
            /usr/sbin/invoke-rc.d $OMSAGENT_WS start
        elif [ -x /sbin/service ]; then
            /sbin/service $OMSAGENT_WS start
        elif [ -x /bin/systemctl ]; then
            /bin/systemctl start $OMSAGENT_WS
        else
            echo "ERROR:  Unrecognized service controller to start OMS Agent service" 1>&2
            exit 1
        fi
    fi
    WS_STATUS=$?
    return $WS_STATUS
}

stop_omsagent()
{
    if remove_PIDfile_unless_omsagent_running; then
        # If systemd lives here, then we have a systemd unit file
        if pidof systemd 1> /dev/null 2> /dev/null; then
            /bin/systemctl stop $OMSAGENT_WS
        else
            if [ -x /usr/sbin/invoke-rc.d ]; then
                /usr/sbin/invoke-rc.d $OMSAGENT_WS stop
            elif [ -x /sbin/service ]; then
                /sbin/service $OMSAGENT_WS stop
            elif [ -x /bin/systemctl ]; then
                /bin/systemctl stop $OMSAGENT_WS
            else
                echo "ERROR:  Unrecognized service controller to stop OMS Agent service" 1>&2
                exit 1
            fi
        fi
    fi
    WS_STATUS=$?
    return $WS_STATUS
}

restart_omsagent()
{
    exit_if_agent_not_onboarded

    if ! remove_PIDfile_unless_omsagent_running; then
        start_omsagent
        return
    else
        enable_omsagent_service
    fi

    # If systemd lives here, then we have a systemd unit file
    if pidof systemd 1> /dev/null 2> /dev/null; then
        /bin/systemctl restart $OMSAGENT_WS
    else
        if [ -x /usr/sbin/invoke-rc.d ]; then
            /usr/sbin/invoke-rc.d $OMSAGENT_WS restart
        elif [ -x /sbin/service ]; then
            /sbin/service $OMSAGENT_WS restart
        elif [ -x /bin/systemctl ]; then
            /bin/systemctl restart $OMSAGENT_WS
        else
            echo "ERROR:  Unrecognized service controller to restart OMS Agent service" 1>&2
            exit 1
        fi
    fi
    WS_STATUS=$?
    return $WS_STATUS
}


find_systemd_dir()
{
    # Various distributions have different paths for systemd unit files ...
    local UNIT_DIR_LIST="/usr/lib/systemd/system /lib/systemd/system"

    if pidof systemd 1> /dev/null 2> /dev/null; then
        # Be sure systemctl lives where we expect it to
        if [ ! -f /bin/systemctl ]; then
            echo "FATAL: Unable to locate systemctl program" 1>&2
            exit 1
        fi

        # Find systemd unit directory
        for i in ${UNIT_DIR_LIST}; do
            if [ -d $i ]; then
                echo ${i}
                return 0
            fi
        done

        # Didn't find unit directory, that's fatal
        echo "FATAL: Unable to resolve systemd unit directory!" 1>&2
        exit 1
    else
		WS_STATUS=1
		return $WS_STATUS
    fi
}

enable_omsagent_service()
{
    exit_if_agent_not_onboarded
    if [ ! -f $CONF_DIR/.service_registered ] && [ -f $OMSADMIN_CONF ]; then
        echo "INFO:  Configuring OMS agent service $WORKSPACE_ID ..."
        if [ ! -f $BIN_DIR/$OMSAGENT_WS ]; then
            ln -s $BIN_DIR/omsagent $BIN_DIR/$OMSAGENT_WS
        fi

        if pidof systemd 1> /dev/null 2> /dev/null; then
            # systemd
            local systemd_dir=$(find_systemd_dir)
            local omsagent_service=${systemd_dir}/$OMSAGENT_WS.service

            cp /etc/opt/microsoft/omsagent/sysconf/omsagent.systemd $omsagent_service 

            sed -i s,%CONF_DIR_WS%,$CONF_DIR,1 $omsagent_service
            sed -i s,%CERT_DIR_WS%,$CERT_DIR,1 $omsagent_service
            sed -i s,%TMP_DIR_WS%,$TMP_DIR,1 $omsagent_service
            sed -i s,%RUN_DIR_WS%,$RUN_DIR,1 $omsagent_service
            sed -i s,%STATE_DIR_WS%,$STATE_DIR,1 $omsagent_service
            sed -i s,%LOG_DIR_WS%,$LOG_DIR,1 $omsagent_service

            /bin/systemctl daemon-reload
            /bin/systemctl -q enable $OMSAGENT_WS
        else
            local omsagent_initd=/etc/init.d/$OMSAGENT_WS
            cp /etc/opt/microsoft/omsagent/sysconf/omsagent.ulinux $omsagent_initd

            sed -i s,%WORKSPACE_ID%,$WORKSPACE_ID,g $omsagent_initd

            if [ -x /usr/sbin/update-rc.d ]; then
                update-rc.d $OMSAGENT_WS defaults > /dev/null
            elif [ -x /usr/lib/lsb/install_initd ]; then
                /usr/lib/lsb/install_initd $omsagent_initd
            elif [ -x /sbin/chkconfig ]; then
                /sbin/chkconfig --add $OMSAGENT_WS > /dev/null
            else
                echo "FATAL:  Could not find a service controller to configure the OMS Agent Service."
                exit 9
            fi
        fi
        WS_STATUS=$?
        if [ "$WS_STATUS" -eq 0 ]; then
            touch  $CONF_DIR/.service_registered
        fi
    fi 
    return $WS_STATUS
}


disable_omsagent_service()
{
    # Stop the server if it's running
    stop_omsagent

    # Registered as a systemd service?
    local systemd_dir=$(find_systemd_dir)
    local omsagent_service=${systemd_dir}/$OMSAGENT_WS.service
    local omsagent_initd=/etc/init.d/$OMSAGENT_WS
    if [ -f $omsagent_service ]; then
        echo "INFO:  Unconfiguring OMS agent (systemd) service $WORKSPACE_ID ..."
        /bin/systemctl -q disable $OMSAGENT_WS
        rm -f $omsagent_service
        /bin/systemctl daemon-reload
        WS_STATUS=$?
    elif [ -f $omsagent_initd ]; then
        echo "INFO:  Unconfiguring OMS agent service $WORKSPACE_ID ..."
        if [ -f /usr/sbin/update-rc.d ]; then
            /usr/sbin/update-rc.d -f $OMSAGENT_WS remove
        elif [ -x /usr/lib/lsb/remove_initd ]; then
            /usr/lib/lsb/remove_initd $omsagent_initd
        elif [ -x /sbin/chkconfig ]; then
            /sbin/chkconfig --del $OMSAGENT_WS > /dev/null
        else
            echo "FATAL:  Unrecognized Service Controller to unregister OMS Agent Service."
            exit 1
        fi
        WS_STATUS=$?

        rm $omsagent_initd
    fi
    rm -f $CONF_DIR/.service_registered
    return $WS_STATUS
}

check_ws_and_invoke()
{
    fcso_new
    for ws_id in $NON_OMS_WS
    do
        ls -1 $ETC_DIR | grep -w ${ws_id} > /dev/null 2>&1
        if [ $? -eq 0 ]; then
            setup_variables ${ws_id}
            $1
            WS_STATUS=$?
            fcso_increment $1 $WORKSPACE_ID $WS_STATUS
        fi
    done
}

start_all_omsagent()
{
    fcso_new
    for ws_id in `ls -1 $ETC_DIR | grep -E $WORKSPACE_REGEX`
    do
        setup_variables ${ws_id}
        start_omsagent
        WS_STATUS=$?
        fcso_increment start_omsagent $WORKSPACE_ID $WS_STATUS
    done

    check_ws_and_invoke start_omsagent
    WS_STATUS=$FCSO_FailCount
    return $WS_STATUS
}

stop_all_omsagent()
{
    fcso_new
    for ws_id in `ls -1 $ETC_DIR | grep -E $WORKSPACE_REGEX`
    do
        setup_variables ${ws_id}
        stop_omsagent
        WS_STATUS=$?
        fcso_increment stop_omsagent $WORKSPACE_ID $WS_STATUS
    done

    check_ws_and_invoke stop_omsagent
    WS_STATUS=$FCSO_FailCount
    return $WS_STATUS
}

restart_all_omsagent()
{
    fcso_new
    for ws_id in `ls -1 $ETC_DIR | grep -E $WORKSPACE_REGEX`
    do
        setup_variables ${ws_id}
        restart_omsagent
        WS_STATUS=$?
        fcso_increment restart_omsagent $WORKSPACE_ID $WS_STATUS
    done

    check_ws_and_invoke restart_omsagent
    WS_STATUS=$FCSO_FailCount
    return $WS_STATUS
}

enable_all_omsagent_services()
{
    fcso_new
    for ws_id in `ls -1 $ETC_DIR | grep -E $WORKSPACE_REGEX`
    do
        setup_variables ${ws_id}
        enable_omsagent_service
        WS_STATUS=$?
        fcso_increment enable_omsagent $WORKSPACE_ID $WS_STATUS
    done

    check_ws_and_invoke enable_omsagent_service
    WS_STATUS=$FCSO_FailCount
    return $WS_STATUS
}

disable_all_omsagent_services()
{
    fcso_new
    for ws_id in `ls -1 $ETC_DIR | grep -E $WORKSPACE_REGEX`
    do
        setup_variables ${ws_id}
        disable_omsagent_service
        WS_STATUS=$?
        fcso_increment disable_omsagent $WORKSPACE_ID $WS_STATUS
    done

    check_ws_and_invoke disable_omsagent_service
    WS_STATUS=$FCSO_FailCount
    return $WS_STATUS
}

case "$1" in
    functions)
        setup_variables $2
        ;;

    is-running) # As it is not a Shell success boolean, but a more
                # traditional truth value boolean we return here,
                # Presumably this return value is used by programs
                # in another language or environment.
        setup_variables $2
        is_omsagent_running
        exit $?
        ;;

    start)
        verify_privileges
        if [ -z $2 ]; then
            start_all_omsagent
        else
            setup_variables $2
            start_omsagent
        fi
        ;;

    stop)
        verify_privileges
        if [ -z $2 ]; then
            stop_all_omsagent
        else
            setup_variables $2
            stop_omsagent
        fi
        ;;

    restart)
        verify_privileges
        if [ -z $2 ]; then
            restart_all_omsagent
        else
            setup_variables $2
            restart_omsagent
        fi
        ;;

    reload)
        verify_privileges
        # TODO: Due to a bug in OMS right now, we can't reload via a signal
        if [ -z $2 ]; then
            restart_all_omsagent
        else
            setup_variables $2
            restart_omsagent
        fi
        ;;

    find-systemd-dir)
        find_systemd_dir
        ;;

    enable)
        verify_privileges
        if [ -z $2 ]; then
            enable_all_omsagent_services
        else
            setup_variables $2
            enable_omsagent_service
        fi
        ;;

    disable)
        verify_privileges
        if [ -z $2 ]; then
            disable_all_omsagent_services
        else
            setup_variables $2
            disable_omsagent_service
        fi
        ;;

    *)
        echo "Unknown parameter : $1" 1>&2
        exit 1
        ;;
esac

exit $WS_STATUS
